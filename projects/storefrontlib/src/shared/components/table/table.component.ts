import {
  ChangeDetectionStrategy,
  Component,
  EventEmitter,
  HostBinding,
  Input,
  isDevMode,
  Output,
} from '@angular/core';
import {
  Table,
  TableDataOutletContext,
  TableFieldOptions,
  TableHeader,
  TableHeaderOutletContext,
} from './table.model';

/**
 * The table component provides a generic DOM structure based on the `dataset` input.
 * The `Table` dataset contains a type, table structure and table data.
 *
 * The table component only supports horizontal table structure.
 *
 * The implementation is fairly "dumb" and only provides the following features:
 * - Use outlet for table headers (`<th>`) and cells (`<td>`).
 * - Localizing table headers, using the `I18nModule`.
 * - Add CSS classes on each cell to
 *
 * Al features are optional.
 *
 * By default, the headers and columns are rendered with an outlet template. The template
 * reference is generated by concatenating the table `type` and table header `key`.
 * The following snippet shows an outlet generated for a table header, for the table type
 * "cost-center" with a label "name":
 *
 * ```
 * <th>
 *   <template cxOutlet="tbl.cost-center.header.name">
 *     [localized label is generated here]
 *   </template>
 * </th>
 * ```
 *
 * Similarly, the `<td>` is generated with the outlet template reference `tbl.cost-center.data.name`.
 *
 * This allows smart components to further customize the table rendering. More over, customers can
 * customize the header and data by using the generated outlets.
 */
@Component({
  selector: 'cx-table',
  templateUrl: './table.component.html',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class TableComponent {
  @HostBinding('attr.__cx-table-type') tableType: string;

  protected _dataset: Table;
  @Input()
  set dataset(dataset: Table) {
    this._dataset = dataset;
    this.addTableDebugInfo();
  }

  get dataset(): Table {
    return this._dataset;
  }

  /**
   * The paginateEvent is triggered when a new page is required. This includes sorting.
   */
  @Output() sortEvent: EventEmitter<string> = new EventEmitter();

  /**
   * Returns the configured data value by the label key.
   * If there's no headerKey available, or no corresponding value, the
   * first value in the data row is returned.
   */
  getDataValue(dataRow: any, headerKey: string, index: number): string {
    return dataRow[headerKey] || Object.values(dataRow)[index];
  }

  /**
   * Returns the static label for the given field, if available.
   */
  sort(header: TableHeader) {
    if (header.sortCode) {
      this.sortEvent.emit(header.sortCode);
    }
  }

  /**
   * Returns the static label for the given field, if available.
   */
  getHeader(field): string {
    if (typeof this.options?.fields?.[field]?.label === 'string') {
      return <string>this.options?.fields?.[field]?.label;
    }
  }

  /**
   * Returns the localized label for the given field.
   *
   * The localized label is either driven by the configured `label.i18nKey`
   * or concatenated by the table `type` and field `key`:
   *
   * `[tableType].[fieldKey]`
   *
   * The localized header can be translated with the `cxTranslate` pipe or `TranslationService`.
   */
  getLocalizedHeader(field: string): string {
    return (
      (this.options?.fields?.[field]?.label as TableHeader)?.i18nKey ||
      `${this.type}.${field}`
    );
  }

  /**
   * Returns the header (th) outlet reference for the given field.
   */
  getHeaderOutletRef(field: string): string {
    return `table.${this.type}.header.${field}`;
  }

  /**
   * Returns the header (th) outlet context for the given field.
   */
  getHeaderOutletContext(field: string): TableHeaderOutletContext {
    return { _field: field, _options: this.options };
  }

  /**
   * Returns the data (td) outlet reference for the given field.
   */
  getDataOutletRef(field: string): string {
    return `table.${this.type}.data.${field}`;
  }

  /**
   * Returns the data (td) outlet context for the given field.
   */
  getDataOutletContext(field: string, data: any): TableDataOutletContext {
    return { _field: field, _options: this.options, ...data };
  }

  /**
   * Generates the table type into the UI in devMode, so that developers
   * can easily get the notion of the table type.
   */
  protected addTableDebugInfo() {
    if (isDevMode && this.type) {
      this.tableType = this.type;
    }
  }

  protected getFieldOptions(field: string): TableFieldOptions {
    return this.options?.fields?.[field];
  }

  protected get type() {
    return this.dataset?.structure?.type;
  }

  protected get options() {
    return this.dataset?.structure?.options;
  }
}
